When I was reading books on Haskell, I got interested in how to use
some of Haskell's features of parallel programming. The Collatz conjecture
seemed to be an excellent way to get started.

The Collatz conjecture states that, given any arbitrary positive integer,
the following function, performed repeatedly, will give a sequence that
eventually reaches the number 1.

def f(n):
	assert n > 0
	if n % 2 == 0:
		return n/2
	else:
		return 3*n + 1

An example sequence (called a waterfall sequence) generated by this method:
n = 6 yields a sequence of [6,3,10,5,16,8,4,2,1]. 
As you can see, this sequence does reach the number 1, so the Collatz conjecture
holds true for n = 6.

Experimental evidence has shown that
the conjecture holds for all numbers between 0 and 10^24. This makes it
great for testing parallel computing, since it's very simple but the potential
for significant computation time is huge.

I purposely implemented these methods fairly naively, so as to best test the
performance gains I received from GHC.

-------------
This project can be compiled by using
ghc -O2 --make CollatzMain.hs -threaded -rtsopts
